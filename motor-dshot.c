/*
Code to generate DSHOT protocol signals to a Raspberry Pi GPIO
output. This code uses 'pio' library allowing to generate signal
while not loading the main CPU.
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>
#include <stdint.h>
#include <string.h>

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "dshot.pio.h"

// #include "../motor-common.h"

// Strangely, my ESC does not conform to the specificaion. Its timing is 18% faster
// than the spec. This value is used to adjust it.
#define DSHOT_DIVIDER_FACTOR 	0.82

// Maximal number of PIO state machines. This number comes from PIO hardware.
#define DSHOT_PIO_SM_MAX         4

// Each PIO state machine generates DSHOT to 1, 2, 4, 8 or 16 continuous GPIO pins
// depending on the value of the following macro. Higher value means that you may use more pins and
// less state machines (if your motors are connected to continuous GPIO numbers). However, it
// also means that more data is sent to FIFO. If you restrict PINS_PER_SM to 2 then each state
// machine can be updated by a single push (while having up to 8 motors). In general, the optimal
// case is when you are able to connect all your motors to a single continuous range of GPIOs and
// you set PINS_PER_SM to the number of motors.
// !!! If you change this value, you have to change it in 'dshot.pio' file as well !!!
#define PINS_PER_SM              8

// Max GPIO pins we can handle
#define DSHOT_NUM_PINS           32

#define DSHOT_FRAME_LEN          16
// 3D mode, if dshot3dMode != 0 then reverse rotation is enabled
static int dshot3dMode = 0;
unsigned dshotVersion = 600;  // can be one of 150, 300, 600, 1200, ... and can assigned before init.


enum {
    DSHOT_CMD_MOTOR_STOP = 0,
    DSHOT_CMD_BEACON1,
    DSHOT_CMD_BEACON2,
    DSHOT_CMD_BEACON3,
    DSHOT_CMD_BEACON4,
    DSHOT_CMD_BEACON5,
    DSHOT_CMD_ESC_INFO, // V2 includes settings
    DSHOT_CMD_SPIN_DIRECTION_1,
    DSHOT_CMD_SPIN_DIRECTION_2,
    DSHOT_CMD_3D_MODE_OFF,
    DSHOT_CMD_3D_MODE_ON,
    DSHOT_CMD_SETTINGS_REQUEST, // Currently not implemented
    DSHOT_CMD_SAVE_SETTINGS,
    DSHOT_CMD_SPIN_DIRECTION_NORMAL = 20,
    DSHOT_CMD_SPIN_DIRECTION_REVERSED = 21,
    DSHOT_CMD_LED0_ON, // BLHeli32 only
    DSHOT_CMD_LED1_ON, // BLHeli32 only
    DSHOT_CMD_LED2_ON, // BLHeli32 only
    DSHOT_CMD_LED3_ON, // BLHeli32 only
    DSHOT_CMD_LED0_OFF, // BLHeli32 only
    DSHOT_CMD_LED1_OFF, // BLHeli32 only
    DSHOT_CMD_LED2_OFF, // BLHeli32 only
    DSHOT_CMD_LED3_OFF, // BLHeli32 only
    DSHOT_CMD_AUDIO_STREAM_MODE_ON_OFF = 30, // KISS audio Stream mode on/Off
    DSHOT_CMD_SILENT_MODE_ON_OFF = 31, // KISS silent Mode on/Off
    DSHOT_CMD_SIGNAL_LINE_TELEMETRY_DISABLE = 32,
    DSHOT_CMD_SIGNAL_LINE_CONTINUOUS_ERPM_TELEMETRY = 33,
    DSHOT_CMD_MAX = 47
};

struct dshotPioPins {
    int pinBase;
    int pinCount;
};

// pin distribution among state machines, can be edited manually or auto generated by dshotSmInit().
struct dshotPioPins dshotSm[DSHOT_PIO_SM_MAX] = {
    {21, 3},	// sm[0] will sent to GPIO21, GPIO22 and GPIO23
    {4, 1},     // sm[1] will sent to GPIO4
    {0, 0},     // sm[2] is inactive
    {0, 0}      // sm[3] is inactive
};


struct pinToSmStr {
    int sm;
    int mask;
};

struct pinToSmStr dshotPinToSm[DSHOT_NUM_PINS];

// state machines index acquired from pio lib
static PIO  dshotPio;
static int  dshotSmi[DSHOT_PIO_SM_MAX];
static uint dshotLoadedOffset;

////////////////////////////////////////////////////////////////////////

static unsigned dshotAddChecksumAndTelemetry(int packet, int telem) {
  unsigned pp, ss;
  pp = (packet << 1) | (telem & 1);
  ss = (pp ^ (pp>>4) ^ (pp>>8)) & 0x0f;
  return ((pp<<4) | ss);
}

// precompute continuous areas of pins so that all pins are covered by 4 state machines
static int dshotSmInit(int motorPins[], int motorMax) {
    int		i, sm, pin, base, count;
    int8_t 	pinMap[DSHOT_NUM_PINS];

    memset(pinMap, 0, sizeof(pinMap));
    for(i=0; i<motorMax; i++) {
	pin = motorPins[i];
	assert(pin >= 0 && pin < DSHOT_NUM_PINS);
	pinMap[pin] = 1;
    }
    // assign continuos regions of pins to state machines
    memset(dshotSm, 0, sizeof(dshotSm));
    i = 0;
    while(pinMap[i] == 0 && i<DSHOT_NUM_PINS) i++;
    // No pin's found
    if (i>=DSHOT_NUM_PINS) return(-2);
    for(sm=0; sm<DSHOT_PIO_SM_MAX; sm++) {
	base = i;
	while(pinMap[i] != 0 && i<base+PINS_PER_SM && i<DSHOT_NUM_PINS) i++;
	count = i-base;
	dshotSm[sm].pinBase = base;
	dshotSm[sm].pinCount = count;
	while(pinMap[i] == 0 && i<DSHOT_NUM_PINS) i++;
	if (i>=DSHOT_NUM_PINS) return(0);
    }
    // Hmm I am running out of state machines
    return(-1);
}

// precompute mapping from pin number to assigned state machine and pin's bit mask
static void dshotPinToSmInit() {
    int i, j, pin;

    memset(dshotPinToSm, 0, sizeof(dshotPinToSm));
    for(i=0; i<DSHOT_PIO_SM_MAX; i++) {
	for(j=0; j<dshotSm[i].pinCount; j++) {
	    pin = dshotSm[i].pinBase + j;
	    dshotPinToSm[pin].sm = i;
	    dshotPinToSm[pin].mask = (1 << j);
	}
    }
}

static void dshotSendFrames(int motorPins[], int motorMax, unsigned frame[]) {
  int         i, j, k, bi;
  unsigned    bit;
  uint16_t    b[DSHOT_PIO_SM_MAX][DSHOT_FRAME_LEN];
  uint32_t    bb;
  int	      pin, sm, mask;
    
  assert(motorMax < DSHOT_NUM_PINS);

  memset(b, 0, sizeof(b));

  // precompute broadcasting to state machines for each message bit
  for(i=0; i<motorMax; i++) {
    pin = motorPins[i];
    assert(pin < DSHOT_NUM_PINS);
    sm = dshotPinToSm[pin].sm;
    mask = dshotPinToSm[pin].mask;
    bit = 0x8000;
    for(bi=0; bi<DSHOT_FRAME_LEN; bi++) {
      if ((frame[i] & bit)) b[sm][bi] |= mask;
      bit = (bit >> 1);
    }
  }

  // send precomputed frames to each state machine by packing them into 32 bit TX FIFOs
  for(i=0; i<DSHOT_PIO_SM_MAX; i++) {
    sm = dshotSmi[i];
    if (sm >= 0 && dshotSm[i].pinCount > 0) {
      if (pio_sm_is_tx_fifo_empty(dshotPio, sm)) {
	pio_sm_set_enabled(dshotPio, sm, false);
	for(j=0; j<DSHOT_FRAME_LEN; j+=32/PINS_PER_SM) {
	  bb = 0;
	  for(k=0; k<32/PINS_PER_SM; k++) {
	    bb |= (b[i][j+k] << k*PINS_PER_SM);
	  }
	  pio_sm_put(dshotPio, sm, bb);
	}
	pio_sm_set_enabled(dshotPio, sm, true);
      } else {
	fprintf(stderr, "Warning: a dshot frame skipped\n");
      }
    }
  }
}



//////////////////////////////////////////////////////////////////////////////////////////////
// Main exported functions of the module implementing raspilot motor instance.
//////////////////////////////////////////////////////////////////////////////////////////////

// This function allows to set bidirectional rotation (mode3dFlag!=0) and reverse rotation logic (reverseDirectionFlag!=0).
// Changing 3D mode is interfering with rotation direction (at least on my ESC), so always reset the direction when changing 3D

void motorImplementationSet3dModeAndSpinDirection(int motorPins[], int motorMax, int mode3dFlag, int reverseDirectionFlag) {
  // to be implemented
}


static void dshot_program_init(PIO pio, uint sm, uint offset, uint pin, uint pincount, double clkDivider) {
   pio_sm_set_consecutive_pindirs(pio, sm, pin, pincount, true);
   pio_sm_config c = dshot_program_get_default_config(offset);
   sm_config_set_out_pins(&c, pin, pincount);
   sm_config_set_set_pins(&c, pin, pincount);
   sm_config_set_out_shift (&c, true, true, 32);
   sm_config_set_fifo_join (&c, PIO_FIFO_JOIN_TX);
   sm_config_set_clkdiv (&c, clkDivider);
   pio_sm_init(pio, sm, offset, &c);
}

void motorImplementationInitialize(int motorPins[], int motorMax) {
  int    i, r;
  double divider;
    
    // initialize pio library
    stdio_init_all();
    dshotPio = pio0;
    
    r = dshotSmInit(motorPins, motorMax) ;
    if (r != 0) {
      fprintf(stderr, "Error: MotorPins aren't in %d continuous intervals. Can't map.\n", DSHOT_PIO_SM_MAX);
    }
    
    dshotPinToSmInit() ;

    for(i=0; i<motorMax; i++) {
      pio_gpio_init(dshotPio, motorPins[i]);
    }

    for(i=0; i<DSHOT_PIO_SM_MAX; i++) {
      if (dshotSm[i].pinCount > 0) {
	dshotSmi[i] = pio_claim_unused_sm(dshotPio, false);
	if (dshotSmi[i] < 0) fprintf(stderr, "Error: Can't claim state machine number %d\n", i);
	// pio_sm_set_enabled(pio, smi[i], true);
      }
    }

    dshotLoadedOffset = pio_add_program(dshotPio, &dshot_program);
    // printf("loaded offset %d\n", loaded_offset);

    // Set clock divider to the value specified in dshot specification (we use 8 ticks to broadast one bit).
    divider = clock_get_hz(clk_sys) / (dshotVersion * 1000 * 8);
    // My cheap ESC is nearly 20% off the standard. Adjust divider by an ad-hoc value.
    divider *= DSHOT_DIVIDER_FACTOR;
    // printf("clock hz == %d divider == %f\n", clock_get_hz(clk_sys), divider);

   for(i=0; i<DSHOT_PIO_SM_MAX; i++) {
      if (dshotSm[i].pinCount > 0 && dshotSmi[i] >= 0) {
	// printf("init program in sm %d, offset %d, pinbase %d, pincount %d\n", smi[i], loaded_offset, dshotSm[i].pinBase, dshotSm[i].pinCount);
	dshot_program_init(dshotPio, dshotSmi[i], dshotLoadedOffset, dshotSm[i].pinBase, dshotSm[i].pinCount, divider);
	pio_sm_set_enabled(dshotPio, dshotSmi[i], true);
      }
    }
    
}

void motorImplementationFinalize(int motorPins[], int motorMax) {
  /* for some reason this code makes state machines to freeze
     TODO: figure out the proper deinitialization of state machines
  */
  /*
  int i;

  for(i=0; i<DSHOT_PIO_SM_MAX; i++) {
    if (smi[i] >= 0) {
      pio_sm_set_enabled(pio, smi[i], false);
    }
  }
  pio_remove_program (pio, &dshot_program, loaded_offset);
  for(i=0; i<DSHOT_PIO_SM_MAX; i++) {
    if (smi[i] >= 0) {
      pio_sm_unclaim(pio, smi[i]);
    }
  }
  */
}

void motorImplementationSendThrottles(int motorPins[], int motorMax, double motorThrottle[]) {
    int         i;
    unsigned    frame[DSHOT_NUM_PINS+1];
    int         val;

    assert(motorMax < DSHOT_NUM_PINS);

    for(i=0; i<motorMax; i++) {
        if (dshot3dMode) {
            // translate double throttles ranging <-1, 1> to dshot frames.
            if (motorThrottle[i] >= 0) {
                val = motorThrottle[i] * 999 + 1048;
            } else {
                val = -motorThrottle[i] * 999 + 48;
            }
        } else {
            // translate double throttles ranging <0, 1> to dshot frames.
            val = motorThrottle[i] * 1999 + 48;
        }
        // we used command 0 for zero thrust which should be used as arming sequence as well.
	// but in 3d mode we have to be carefull it seems to reset the motor.
        if (/*motorThrottle[i] == 0 || */ val < 48 || val >= 2048) val = DSHOT_CMD_MOTOR_STOP;
        frame[i] = dshotAddChecksumAndTelemetry(val, 0);
    }

    dshotSendFrames(motorPins, motorMax, frame);
}
